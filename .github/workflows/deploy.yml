name: Deploy to VM

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # Nouveau dossier propre, sans droits root hérités
      APP_DIR: /home/${{ secrets.SSH_USER }}/steamdb_app
      GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
      GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
      FIRESTORE_PROJECT: ${{ secrets.FIRESTORE_PROJECT != '' && secrets.FIRESTORE_PROJECT || secrets.GCP_PROJECT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare app dir on VM (no sudo)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          script_stop: true
          envs: APP_DIR
          script: |
            set -euo pipefail
            echo "[INFO] Preparing $APP_DIR on $(hostname) as $(whoami)"
            # Si l'ancien dossier existait avec des fichiers root, on l'ignore et on repart sur un neuf
            mkdir -p "$APP_DIR"
            # Nettoyer uniquement ce que TU peux supprimer
            find "$APP_DIR" -mindepth 1 -maxdepth 1 ! -name logs -exec rm -rf {} + || true
            # Arbo minimale
            mkdir -p "$APP_DIR/dags" "$APP_DIR/etl" "$APP_DIR/dashboard" "$APP_DIR/.github/workflows" "$APP_DIR/logs"
            # Donner des droits permissifs aux logs pour l'UID 50000 dans le conteneur
            chmod -R 0777 "$APP_DIR/logs" || true

      - name: Upload project to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          target: ${{ env.APP_DIR }}
          overwrite: true
          source: "."
          
      - name: Deploy (env + docker compose up)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          script_stop: true
          command_timeout: 60m
          envs: APP_DIR,GCP_PROJECT,GCS_BUCKET,FIRESTORE_PROJECT
          script: |
            set -euo pipefail
            cd "$APP_DIR"

            # retirer un éventuel .git
            rm -rf .git || true

            # générer .env pour docker-compose
            {
              echo "GCP_PROJECT=${GCP_PROJECT}"
              echo "GCS_BUCKET=${GCS_BUCKET}"
              echo "FIRESTORE_PROJECT=${FIRESTORE_PROJECT}"
              echo "AIRFLOW_PORT=8081"
              echo "STREAMLIT_PORT=8501"
              echo "APP_IDS_FILE=/opt/airflow/apps.txt"
            } > .env

            # choisir la bonne commande compose
            if docker compose version >/dev/null 2>&1; then
              DC="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DC="docker-compose"
            else
              echo "[ERROR] docker compose not installed"; exit 1
            fi

            # build & run
            $DC pull || true
            $DC down || true
            $DC up -d --build
            $DC ps

      - name: Airflow health check (optional)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          script_stop: true
          envs: APP_DIR
          script: |
            set -euo pipefail
            cd "$APP_DIR"
            if docker compose ps | grep -q airflow; then
              docker compose exec -T airflow bash -lc 'curl -sf http://localhost:${AIRFLOW_PORT:-8081}/health || true'
            else
              echo "[WARN] Airflow container not found in compose ps"
            fi
